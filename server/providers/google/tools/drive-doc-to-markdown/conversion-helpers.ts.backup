/**
 * HTML to Markdown Conversion Helpers
 * Converts HTML exported from Google Docs to Markdown format using Turndown
 */

import TurndownService from 'turndown';

/**
 * Convert HTML content to Markdown using Turndown library
 */
export function htmlToMarkdown(html: string): string {
  console.log('Converting HTML to Markdown');
  
  // Initialize Turndown with GitHub-flavored markdown options
  const turndownService = new TurndownService({
    headingStyle: 'atx',           // Use # for headings
    hr: '---',                      // Horizontal rule style
    bulletListMarker: '-',          // Use - for unordered lists
    codeBlockStyle: 'fenced',       // Use ``` for code blocks
    fence: '```',                   // Code fence marker
    emDelimiter: '*',               // Use * for emphasis
    strongDelimiter: '**',          // Use ** for strong
    linkStyle: 'inlined',           // Use [text](url) style
    linkReferenceStyle: 'full',     // Full reference style for links
  });
  
  // Add GitHub Flavored Markdown extensions
  turndownService.use([
    // Strikethrough support
    (service) => {
      service.addRule('strikethrough', {
        filter: ['s', 'del'],
        replacement: (content) => `~~${content}~~`
      });
    },
    // Tables support (Turndown handles tables by default)
    // Underline to italic (markdown has no underline)
    (service) => {
      service.addRule('underline', {
        filter: ['u'],
        replacement: (content) => `*${content}*`
      });
    }
  ]);
  
  // Convert HTML to Markdown
  const markdown = turndownService.turndown(html);
  
  // Normalize special characters (smart quotes, em-dashes, etc.)
  const normalized = normalizeSpecialCharacters(markdown);
  
  // Clean up excessive newlines (max 2 consecutive)
  const cleaned = normalized.replace(/\n{3,}/g, '\n\n').trim();
  
  console.log(`  Conversion complete: ${cleaned.length} characters`);
  return cleaned;
}

/**
 * Convert a DOM element and its children to Markdown
 */
function convertElementToMarkdown(element: Element, document: Document): string {
  const tagName = element.tagName.toLowerCase();
  
  // Handle different element types
  switch (tagName) {
    case 'h1':
      return `# ${getTextContent(element)}\n\n`;
    case 'h2':
      return `## ${getTextContent(element)}\n\n`;
    case 'h3':
      return `### ${getTextContent(element)}\n\n`;
    case 'h4':
      return `#### ${getTextContent(element)}\n\n`;
    case 'h5':
      return `##### ${getTextContent(element)}\n\n`;
    case 'h6':
      return `###### ${getTextContent(element)}\n\n`;
    
    case 'p':
      return convertParagraph(element, document);
    
    case 'ul':
      return convertUnorderedList(element, document, 0);
    
    case 'ol':
      return convertOrderedList(element, document, 0);
    
    case 'table':
      return convertTable(element, document);
    
    case 'img':
      return convertImage(element);
    
    case 'pre':
      return convertCodeBlock(element, document);
    
    case 'a':
      return convertLink(element, document);
    
    case 'strong':
    case 'b':
      return `**${getTextContent(element)}**`;
    
    case 'em':
    case 'i':
      return `*${getTextContent(element)}*`;
    
    case 'code':
      return `\`${getTextContent(element)}\``;
    
    case 's':
    case 'strike':
    case 'del':
      return `~~${getTextContent(element)}~~`;
    
    case 'u':
      // Underline maps to italic in markdown (no native underline support)
      return `*${getTextContent(element)}*`;
    
    case 'sup':
      return `<sup>${getTextContent(element)}</sup>`;
    
    case 'sub':
      return `<sub>${getTextContent(element)}</sub>`;
    
    case 'br':
      return '\n';
    
    case 'hr':
      return '\n---\n\n';
    
    // Container elements - process children
    case 'body':
    case 'div':
    case 'span':
    case 'section':
    case 'article':
      return convertChildren(element, document);
    
    // Skip these elements
    case 'head':
    case 'style':
    case 'script':
    case 'meta':
    case 'link':
      return '';
    
    default:
      // For unknown elements, just process children
      return convertChildren(element, document);
  }
}

/**
 * Convert paragraph with inline formatting
 */
function convertParagraph(element: Element, document: Document): string {
  const content = convertInlineContent(element, document);
  
  // Empty paragraphs become single newline
  if (!content.trim()) {
    return '\n';
  }
  
  return `${content}\n\n`;
}

/**
 * Convert inline content (handles bold, italic, links, etc.)
 */
function convertInlineContent(element: Element, document: Document): string {
  let result = '';
  
  for (const child of Array.from(element.childNodes)) {
    if (child.nodeType === 3) { // Text node
      result += child.textContent || '';
    } else if (child.nodeType === 1) { // Element node
      const childElement = child as Element;
      const tagName = childElement.tagName.toLowerCase();
      
      switch (tagName) {
        case 'strong':
        case 'b':
          result += `**${getTextContent(childElement)}**`;
          break;
        
        case 'em':
        case 'i':
          result += `*${getTextContent(childElement)}*`;
          break;
        
        case 'code':
          result += `\`${getTextContent(childElement)}\``;
          break;
        
        case 's':
        case 'strike':
        case 'del':
          result += `~~${getTextContent(childElement)}~~`;
          break;
        
        case 'u':
          // Underline maps to italic in markdown
          result += `*${getTextContent(childElement)}*`;
          break;
        
        case 'a':
          const href = childElement.getAttribute('href') || '';
          const text = getTextContent(childElement);
          result += `[${text}](${href})`;
          break;
        
        case 'br':
          result += '\n';
          break;
        
        case 'img':
          const src = childElement.getAttribute('src') || '';
          const alt = childElement.getAttribute('alt') || '';
          result += `![${alt}](${src})`;
          break;
        
        default:
          // Recursively process other inline elements
          result += convertInlineContent(childElement, document);
      }
    }
  }
  
  return result;
}

/**
 * Convert unordered list
 */
function convertUnorderedList(element: Element, document: Document, depth: number): string {
  const items = Array.from(element.children).filter(child => child.tagName.toLowerCase() === 'li');
  const indent = '  '.repeat(depth);
  
  let result = '';
  for (const item of items) {
    const content = convertListItem(item, document, depth);
    result += `${indent}- ${content}\n`;
  }
  
  return result + '\n';
}

/**
 * Convert ordered list
 */
function convertOrderedList(element: Element, document: Document, depth: number): string {
  const items = Array.from(element.children).filter(child => child.tagName.toLowerCase() === 'li');
  const indent = '  '.repeat(depth);
  
  let result = '';
  for (let i = 0; i < items.length; i++) {
    const content = convertListItem(items[i], document, depth);
    result += `${indent}${i + 1}. ${content}\n`;
  }
  
  return result + '\n';
}

/**
 * Convert list item (handles nested lists)
 */
function convertListItem(element: Element, document: Document, depth: number): string {
  let result = '';
  
  for (const child of Array.from(element.childNodes)) {
    if (child.nodeType === 3) { // Text node
      result += child.textContent || '';
    } else if (child.nodeType === 1) { // Element node
      const childElement = child as Element;
      const tagName = childElement.tagName.toLowerCase();
      
      if (tagName === 'ul') {
        // Nested unordered list
        result += '\n' + convertUnorderedList(childElement, document, depth + 1);
      } else if (tagName === 'ol') {
        // Nested ordered list
        result += '\n' + convertOrderedList(childElement, document, depth + 1);
      } else {
        // Process inline content
        result += convertInlineContent(childElement, document);
      }
    }
  }
  
  return result.trim();
}

/**
 * Convert code block (pre > code) to fenced code block
 */
function convertCodeBlock(element: Element, document: Document): string {
  // Extract code content from <code> child if present
  const codeElement = element.querySelector('code');
  const content = codeElement ? getTextContent(codeElement) : getTextContent(element);
  
  // Try to detect language from class attribute (e.g., "language-javascript")
  const className = codeElement?.getAttribute('class') || element.getAttribute('class') || '';
  const languageMatch = className.match(/language-(\w+)/);
  const language = languageMatch ? languageMatch[1] : '';
  
  return `\n\`\`\`${language}\n${content}\n\`\`\`\n\n`;
}

/**
 * Convert table to Markdown table format
 */
function convertTable(element: Element, document: Document): string {
  const rows: string[][] = [];
  
  // Extract table rows
  const tableRows = Array.from(element.querySelectorAll('tr'));
  
  for (const row of tableRows) {
    const cells = Array.from(row.querySelectorAll('td, th'));
    const cellContents = cells.map(cell => getTextContent(cell).trim());
    rows.push(cellContents);
  }
  
  if (rows.length === 0) {
    return '';
  }
  
  // Build markdown table
  let result = '';
  
  // Header row (use first row as header)
  const headerRow = rows[0];
  result += '| ' + headerRow.join(' | ') + ' |\n';
  
  // Separator row
  result += '| ' + headerRow.map(() => '---').join(' | ') + ' |\n';
  
  // Data rows
  for (let i = 1; i < rows.length; i++) {
    const dataRow = rows[i];
    // Pad cells to match header count
    while (dataRow.length < headerRow.length) {
      dataRow.push('');
    }
    result += '| ' + dataRow.join(' | ') + ' |\n';
  }
  
  return result + '\n';
}

/**
 * Convert image element
 */
function convertImage(element: Element): string {
  const src = element.getAttribute('src') || '';
  const alt = element.getAttribute('alt') || '';
  return `![${alt}](${src})\n\n`;
}

/**
 * Convert link element
 */
function convertLink(element: Element, document: Document): string {
  const href = element.getAttribute('href') || '';
  const text = getTextContent(element);
  return `[${text}](${href})`;
}

/**
 * Convert all children of an element
 */
function convertChildren(element: Element, document: Document): string {
  let result = '';
  
  for (const child of Array.from(element.childNodes)) {
    if (child.nodeType === 3) { // Text node
      result += child.textContent || '';
    } else if (child.nodeType === 1) { // Element node
      result += convertElementToMarkdown(child as Element, document);
    }
  }
  
  return result;
}

/**
 * Get text content from element (recursively extracts all text)
 */
function getTextContent(element: Element): string {
  return element.textContent || '';
}

/**
 * Normalize special characters to markdown-safe equivalents
 * Converts smart quotes, em-dashes, ellipses, etc. to standard ASCII
 */
function normalizeSpecialCharacters(text: string): string {
  return text
    // Smart quotes to straight quotes
    .replace(/[\u2018\u2019]/g, "'")  // ' ' → '
    .replace(/[\u201C\u201D]/g, '"')  // " " → "
    // Em-dash and en-dash to hyphens
    .replace(/\u2014/g, ' -- ')       // — → --
    .replace(/\u2013/g, '-')          // – → -
    // Ellipsis
    .replace(/\u2026/g, '...')        // … → ...
    // Non-breaking spaces
    .replace(/\u00A0/g, ' ')          //   → (space)
    // Multiplication sign
    .replace(/\u00D7/g, 'x')          // × → x
    // Degree symbol (keep as is, widely supported)
    // .replace(/\u00B0/g, ' degrees') 
    // Fraction slashes
    .replace(/\u2044/g, '/')          // ⁄ → /
    // Bullet points outside lists
    .replace(/\u2022/g, '*')          // • → *
    // Other common symbols
    .replace(/\u00A9/g, '(c)')        // © → (c)
    .replace(/\u00AE/g, '(r)')        // ® → (r)
    .replace(/\u2122/g, '(tm)');      // ™ → (tm)
}
